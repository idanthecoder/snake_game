; multi-segment executable file template.

; Welcome To "Snake Game" By Idan Barkin.
; This is my Assembly Project for grade 10. Hope you will enjoy playing!

data segment
    ; add your data here!                      
                                               
    ; constants 
    SCREEN_WIDTH            EQU 320
    SCREEN_HEIGHT           EQU 200
    APPLE_COLOR             EQU 12      ; red
    SNAKE_COLOR             EQU 10      ; green  
    HEAD_COLOR              EQU 2       ; greener  
    BOARD_COLOR             EQU 9       ; blue  
                                        
    GOING_UP                EQU 0       
    GOING_DOWN              EQU 1              
    GOING_LEFT              EQU 2       
    GOING_RIGHT             EQU 3       
                                        
    SPACE                   EQU 2       ; space each square
    ADJUST_X                EQU 100     ; middle it
    ADJUST_Y                EQU 20      ; middle it
    
    
    TRUE                    EQU 1       ; boolean values
    FALSE                   EQU 0       ; boolean values
    
    APPLE_START_POS         EQU 80
    SNAKE_START_POS         EQU 144     ; (the head starting position)  
    
    GET_LENGTH              EQU 16  
    SNAKE_SQUARE            EQU 8
    SHIFT_SQUARE            EQU 3       ; this will be used to multiply/ divide by 8 (or SNAKE_SQUARE) using arithmatical shifts         
    SHIFT_LENGTH            EQU 4       ; this will be used to multiply/ divide by 16 (or GET_LENGTH) using arithmatical shifts        
    ARR_LENGTH              EQU 256
    
    
    LOGO_WIDTH              EQU 90      ; 5 * 18
    LOGO_HEIGHT             EQU 31
    LOGO_START              EQU 17700    

    OVER_WIDTH              EQU 150     ; (18 * 8) + 6 
    OVER_HEIGHT             EQU 31
    OVER_START              EQU 17700

    NO_DIRECTION            EQU 10    
    
    PRINT_SCORE_ROW         EQU 3
    PRINT_SCORE_COL         EQU 1
    PRINT_MAX_SCORE_ROW     EQU 6      
    
    OPENING_QUESTIONS_ROW   EQU 14
    OPENING_QUESTIONS_COL   EQU 6 
    
    CREDIT_ROW              EQU 23
    CREDIT_COL              EQU 0 
    
    DEATH_MESSAGE_ROW       EQU 14
    DEATH_MESSAGE_COL       EQU 2 
    
    STRING_LENGTH           EQU 3
    
    ; variables  

    snake_cell              dw 0 
    head_cell               dw 0 
    direction               dw NO_DIRECTION                          
    snake_length            dw 4    
    count_snake             dw 0
    
    axis_arr                dw ARR_LENGTH dup(0) ; the core of all this game. this array saves the values of the snake, apple, and blank spaces  
    current_x               dw 0
    current_y               dw 0       
    
    current_score           dw 0
    max_score               dw 0                
    
    spacer_x                dw SPACE
    spacer_y                dw SPACE
    
    FORMED_SNAKE            dw FALSE    ; a boolean (0 - false, 1 - true)
    snake_ate_apple         dw FALSE    ; a boolean (0 - false, 1 - true) 
    first_iteration         dw TRUE     ; a boolean (0 - false, 1 - true)        
    snake_head_found        dw FALSE    ; a boolean (0 - false, 1 - true)    
    no_point_yet            dw TRUE     ; a boolean (0 - false, 1 - true)  
    game_needs_to_reset     dw FALSE    ; a boolean (0 - false, 1 - true)      

    FIRST_VALUE_OF_LAST_ROW dw 0
    LAST_VALUE_OF_LAST_ROW  dw 0
    LAST_VALUE_OF_FIRST_ROW dw 0      
    
    
    death_message           db "YOU DIED, click any button to reset... $"    
        
    SCORE_TO_PRINT          db '$$$$'
    MAX_SCORE_TO_PRINT      db '$$$$'
    SCORE_STRING_LENGTH     dw 1
    BACKSPACES              db STRING_LENGTH dup(8)
               
    SCORE_STRING            db 'SCORE: $'
    MAX_SCORE_STRING        db 'MAX SCORE: $'  
    
    QUESTION_INSTRUCTION    DB "PRESS 'I' FOR INSTRUCTIONS$"
    QUESTION_START          DB "PRESS 'ENTER' TO START THE GAME$"
    QUESTION_EXIT           DB "PRESS 'ESC' TO CLOSE THE WINDOW$"
    
                                                                    
    INSTRUCTION_TEXT        DB 10, "Welcome to 'Snake Game' by Idan Barkin!", 10, 10, 10, 13
                            DB "The instructions are very simple:", 10, 10, 13
                            DB "Eat as many apples as you can,", 10, 13
                            DB "while avoiding losing.", 10, 10, 13
                            DB "Moving is done by pressing the arrow", 10, 13 
                            DB "keys.", 10, 10, 13
                            DB "you can go up, down, left or right.", 10, 10, 13
                            DB "Collide with an apple and you gain", 10, 13
                            DB "a point and grow your snake.", 10, 10, 13
                            DB "However...", 10, 10, 13
                            DB "Collide with the edges of the screen or", 10, 13
                            DB "with the snake body and you lose.", 10, 10, 10, 13
                            DB "Press esc to return to main screen...$"
    
    
    CREDIT                  DB "CREATED BY IDAN BARKIN.$"
    
    
    ; big 
    
    LOGO                    DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                   
                            DB 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 10, 10, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0,         0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 0   
                            DB 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 10, 10, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 11, 11, 11, 0, 0, 0, 0, 0, 0, 0, 0,       0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 0   
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 10, 10, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 11, 11, 0, 11, 11, 0, 0, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0,   0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 10, 10, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 0, 0, 14, 14, 0, 0, 0, 0,  0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 10, 10, 0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 0, 14, 14, 0, 0, 0, 0, 0,  0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 10, 10, 0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 14, 14, 0, 0, 0, 0, 0, 0,  0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 10, 10, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 0, 14, 14, 0, 0, 0, 0, 0, 0, 0,  0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 10, 10, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0,  0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 10, 10, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 10, 10, 0, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 10, 10, 0, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 14, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 10, 10, 0, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 14, 14, 14, 0, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                  
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 10, 10, 0, 0, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 0, 0, 0, 0, 0, 0, 0, 14, 14, 14, 0, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                  
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 10, 10, 0, 0, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 0, 0, 0, 0, 0, 0, 14, 14, 14, 0, 0, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 10, 10, 0, 0, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 14, 14, 14, 0, 0, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 10, 10, 0, 0, 0, 0, 0, 10, 10, 0, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 14, 14, 14, 0, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 0   
                            DB 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 10, 10, 0, 0, 0, 0, 0, 10, 10, 0, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 14, 14, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 0   
                            DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,               0, 10, 10, 0, 0, 0, 0, 0, 10, 10, 0, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 14, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,               0, 10, 10, 0, 0, 0, 0, 0, 0, 10, 10, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0,  0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,               0, 10, 10, 0, 0, 0, 0, 0, 0, 10, 10, 0, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 0, 14, 14, 0, 0, 0, 0, 0, 0, 0,  0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,               0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 14, 14, 0, 0, 0, 0, 0, 0,  0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,               0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 0, 14, 14, 0, 0, 0, 0, 0,  0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,               0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 0, 0, 14, 14, 0, 0, 0, 0,  0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,               0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,               0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,               0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 10, 10, 10, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,               0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 13, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                 
                            DB 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 0                 
                            DB 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 10, 10, 0,  0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0, 11, 11, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 0   
                            DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0   
                                   
                                   
                                   
    GAME_OVER               DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,              
                            DB 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0,         0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12, 0,    0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0,   0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             
                            DB 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,       0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12, 0,    0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0,   
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 12, 12, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0,      0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12, 0,    0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0,  
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0,      0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12, 0,    0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0,          
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0,      0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12, 0,    0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0,          
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0,      0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12, 0,    0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0,          
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0,      0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12, 0,    0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0,          
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12, 12, 0,   0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0,          
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 12, 12, 0,  0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0,  0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0,  
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 12, 12, 0, 0, 0, 12, 12, 0,  0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 12, 12, 12, 12, 12, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 12, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0,   0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,         
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 12, 12, 0,     0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0,      0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,         
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0,      0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,      0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 12, 12, 0, 0, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0,         
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,             0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,      0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,         
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,             0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0,         
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,             0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 0, 0, 0, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0,         
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,             0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0,          
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,             0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0,          
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,             0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0,          
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,             0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0,          
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,             0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0,          
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,             0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0,          
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,             0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,         0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0,          
                            DB 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,             0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0,         0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0,          
                            DB 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,      0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0,          
                            DB 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0,      0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0,      0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,   0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0,          
                            DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,              
   
ends

stack segment
    dw   128  dup(0)
ends

code segment
start:
; set segment registers:
    mov ax, data
    mov ds, ax
; graphics mode
    mov ax, 0A000h ; the segment (area in the memory) for mode 13h (Graphic) starts at offset 0 of segment 0A000h all data in this segment is colors 
    mov es, ax

    ; add your code here 

reset_the_game: ; return here when a reset is needed

    mov axis_arr[APPLE_START_POS], -1 ; place the apple   
    
    ; place the snake
    xor cx, cx   
    xor di, di
place_start_snake: 
    mov axis_arr[SNAKE_START_POS + di], cx  ; place the snake head 
    ; add 2: snake head will be on the right
    ; sub 2: snake head will be on the left
    ; add 32: snake head will be dowm
    ; sub 32: snake head will be up   
    add di, 2 
    inc cx
    cmp cx, snake_length
    jle place_start_snake  


    ;use this code to set graphics mode:
    mov ah, 0
    mov al, 13h
    int 10h    
    
    ; set up values that will be used later (so that it wouldnt be needed to calculate them every time
    mov ax, ARR_LENGTH
    sub ax, GET_LENGTH
    shl ax, 1
    mov FIRST_VALUE_OF_LAST_ROW, ax 
    
    mov ax, ARR_LENGTH
    dec ax
    shl ax, 1
    mov LAST_VALUE_OF_LAST_ROW, ax 
     
    mov ax, GET_LENGTH
    dec ax
    shl ax, 1
    mov LAST_VALUE_OF_FIRST_ROW, ax     
    
    
    ; form the opening screen of the game
    call MainScreen 
    
    
    ; print 'SCORE:' and 'MAX SCORE:' in their area of the screen
    mov ah, 2
    mov bh, 0
    mov dh, PRINT_SCORE_ROW-1 ; row
    mov dl, PRINT_SCORE_COL ; col
    int 10h
    
    mov ah, 9   
    lea dx, SCORE_STRING
    int 21h 
    
    mov ah, 2
    mov bh, 0
    mov dh, PRINT_MAX_SCORE_ROW-1 ; row
    mov dl, PRINT_SCORE_COL ; col
    int 10h
    
    mov ah, 9   
    lea dx, MAX_SCORE_STRING
    int 21h  
    
    ; we came here after a reset, make sure the program knows we dont need another one yet
    mov game_needs_to_reset, FALSE 
    
       
; start of the game loop (infinite)    
game_loop:
    
    ; reset screen according to the right positions
    ; this procedure accesses the array using "pass by refernce" method 
    ; this procedure prints the board and calls procedures that will deal with the apple and the snake
    push offset axis_arr 
    call FormBoard 
    
    
    ; check if there is a new direction input form arrows (keyboard)
    ; this procedure changes a variable called "direction".
    ; 0: up, 1: down, 2: left, 3: right
    call CheckDirection
    
    cmp direction, NO_DIRECTION
    je skip
    
    ; change snake position on axis board, according to the direction
    ; this procedure accesses the array using "pass by refernce" method
    ; this procedure also gets the direction and head cell  
    ; this procedure changes the snake position in the array, which will affect the screen in the next iteration, thus create a movment 
    push offset axis_arr
    push head_cell
    push direction
    call CheckAndChangeArrValues 
    
    cmp game_needs_to_reset, TRUE
    je reset_the_game

    ; delay. this will slow the program to a normal run time
    mov ah, 86h 
    mov cx, 01h  ; microsecond(s)
    xor dx, 086A0h  ; microsecond(s)   
    int 15h ; time of delay is cx:dx (100,000 microseconds [1 millisecond])
    jmp continue
    
skip:
    ; reset the booleans
    mov formed_snake, FALSE
    mov count_snake, 0
continue:
    ; reset the spacers
    mov spacer_x, SPACE
    mov spacer_y, SPACE
        
    jmp game_loop ; loop infinitely (move snake automaticly)

ends  
;=========================================================================================================
    
    ; input: this procedure gets nothing
    ; output: this procedure prints the logo of the snake, then asks the user to press 'i' to gain information, ENTER to start playing ot ESC to terminate the program
    
    proc MainScreen 
        push ax
        push dx
        push bx 
        
    start_of_screen:        
        ; reset screen 
        mov ah, 0
        mov al, 13h
        int 10h  
        
        ; call the procedure that will print the logo to the screen
        push LOGO_WIDTH
        push LOGO_HEIGHT
        mov ax, LOGO_START
        push ax  
        push offset LOGO
        call DrawBigText
        
        
        ; display the questions to the user               
        mov ah, 2
        mov bh, 0
        mov dh, OPENING_QUESTIONS_ROW ; row
        mov dl, OPENING_QUESTIONS_COL ; col 
        int 10h     
        mov ah, 9
        lea dx, QUESTION_INSTRUCTION
        int 21h
        
        mov ah, 2
        mov dh, OPENING_QUESTIONS_ROW+2 ; row
        mov dl, OPENING_QUESTIONS_COL   ; col
        int 10h
         
        mov ah, 9
        lea dx, QUESTION_START
        int 21h
        
        mov ah, 2
        mov dh, OPENING_QUESTIONS_ROW+4 ; row
        mov dl, OPENING_QUESTIONS_COL   ; col
        int 10h
        mov ah, 9
        lea dx, QUESTION_EXIT
        int 21h 
        
        
        mov ah, 2
        mov dh, CREDIT_ROW  ; row
        mov dl, CREDIT_COL  ; col
        int 10h
        mov ah, 9
        lea dx, CREDIT
        int 21h 
         
            
    main_screen_loop:
        mov ah, 1
        int 16h ; get keyboard status
        jz main_screen_loop ; if zero flag is active, then no key was pressed 
        
        ; get the value of the pressed key   
        mov ax, 0      
        int 16h
        
        cmp al, 'i' ; if i was pressed
        je print_instructions
        
        cmp al, 'I' ; if I was pressed  
        je print_instructions
        
        cmp al, 13 ; if ENTER was pressed
        je start_the_game
        
        cmp al, 27 ; if esc was pressed
        je terminate_program   
    
        
        jmp main_screen_loop        
     
     
    print_instructions:
        ; reset screen
        mov ah, 0
        mov al, 13h
        int 10h
        ; print the instructions
        mov ah, 9
        lea dx, INSTRUCTION_TEXT
        int 21h
                     
    instruction_loop: 
        ; get the value of the pressed key   
        mov ax, 0      
        int 16h
        cmp al, 27 ; if esc was pressed
        je start_of_screen           
        jmp instruction_loop ; loop until esc is pressed and the opening screen can be displayed again  
        
        
    terminate_program:
        int 19h ; cold reboot
    
        
         
    start_the_game: 
        ; reset screen
        mov ah, 0
        mov al, 13h
        int 10h  
               
        pop bx
        pop dx
        pop ax 
        ret
    endp MainScreen                            
    
;=========================================================================================================
    
    
    TEXT_WIDTH      EQU bp + 10
    TEXT_HEIGHT     EQU bp + 8
    POS_ON_SCREEN   EQU bp + 6
    TEXT_ARR_OFFSET EQU bp + 4
    proc DrawBigText    
        push bp
        mov bp, sp
        push si
        push di
        push cx      
         
        mov si, [TEXT_ARR_OFFSET]
        mov di, [POS_ON_SCREEN]
        mov cx, [TEXT_HEIGHT]
    create_line:      
        push cx
        mov cx, [TEXT_WIDTH]
        shr cx, 1
        cld ; clear direction flag (if direction flag is 0 it means that the operations on strings will increase di and si instead of decreasing it)
        rep movsw ; rep: reatedly, cx times(each time it decrements cx by 2[word size]). movsw: do word sized moves from memory ds:si to es:di
        add di, SCREEN_WIDTH ; 320
        sub di, [TEXT_WIDTH]
        pop cx
        loop create_line    
        
        pop cx
        pop di
        pop si    
        pop bp
        ret 8
    endp DrawBigText              


;=========================================================================================================    
    
    ; the array is accessed using "pass by refence"
    GAME_ARR_OFFSET EQU bp + 4
    COUNTER         EQU bp - 2  ; local
    
    proc FormBoard 
        ; keep the original register values
        push bp
        mov bp, sp
        sub sp, 2 ; free space in stack for local variable
        push di
        push cx
        push ax 
          
        mov di, [GAME_ARR_OFFSET] ; set up the register di to access the array values in cells 
        mov cx, ARR_LENGTH ; set up cx to host the array length, will be used to loop through the array
       
        xor ax, ax   
        mov [COUNTER], ax ; set up the local variable to 0. the local will track the indexes  
         
        ; check if the snake havent been formed yet  
        cmp FORMED_SNAKE, FALSE
        je form_board_loop
          
        mov FORMED_SNAKE, FALSE
        mov snake_head_found, FALSE
        
        ; the loop that will create the screen        
    form_board_loop:     
        
        ; find out the cell's x and y axis, by using this procedue  
        ; the procedure will update the values in "current_x" and "current_y" variables
        push [COUNTER]
        call CellToAxis  
         
        ; multiply by 8 so every square is created in its own territory 
        shl current_x, SHIFT_SQUARE          
        shl current_y, SHIFT_SQUARE
        
        ; adjust the screen to the middle
        add current_x, ADJUST_X
        add current_y, ADJUST_Y 
        
        ; space each square
        call SpaceSquare 
        
        
        ; check if cell is a holder of: apple or snake or is empty
        cmp [di], 0
        jl found_apple
        jg found_snake
        
        ; if cell is empty do this code: 
        
        ; set up the parameters neccessary to call the create square procedure
        mov ax, SNAKE_SQUARE
        push ax  
        push BOARD_COLOR
        push current_x
        push current_y
        call CreateSquare     
         
        
        ; finished this cell square
        jmp continue_looping
        

    found_apple:  
        ; form the apple square
        mov ax, SNAKE_SQUARE
        push ax  
        push APPLE_COLOR
        push current_x
        push current_y
        call CreateSquare 
         
        ; finished this cell square
        jmp continue_looping
        
    found_snake:
        ; check if snake head was found        
        mov ax, snake_length 
        cmp [di], ax
        jne snake_but_no_head
        
        ; snake head was found
        mov ax, [COUNTER]
        shl ax, 1 ; multiply by 2 cause this is a word size array  
        mov head_cell, ax ; save the snake head cell in this variable
        
        mov snake_head_found, TRUE  
        
    snake_but_no_head:
        ; keep those values in the stack and call a procedure that will take care of the snake    
        push [COUNTER]
        push current_x
        push current_y     
        call FormSnake     
            
    continue_looping:
        ; update the value tracker and the indexer
        add di, 2
        inc [COUNTER]       
        
        loop form_board_loop ; loop 256 times (16x16)         
        
        pop ax
        pop cx
        pop di
        add sp, 2  
        pop bp
        ret 2   
    endp FormBoard



;=========================================================================================================
; this procedure takes a cell position and turns it to an axis value
    
    CELL_POS EQU bp + 4 
    proc CellToAxis
        push bp
        mov bp, sp
        push ax
        push bx 
        
        ; do the convertion. 
        ; y = CELL / GetLength
        mov ax, [CELL_POS]  
        shr ax, SHIFT_LENGTH 
        mov current_y, ax       
        
        ; find the x of this y (created an equation for it accually!)
        ; x = CELL - (Y * GetLength)   
        
        ; ax already keeps the x axis position, thus:  
        shl ax, SHIFT_LENGTH   
        mov bx, [CELL_POS] 
        sub bx, ax
        mov current_x, bx  
        
        pop bx
        pop ax
        pop bp   
        ret 2 
    endp CellToAxis 
;=========================================================================================================   
    
    CELL_OF_SNAKE   EQU bp + 8
    SNAKE_X         EQU bp + 6
    SNAKE_Y         EQU bp + 4
    proc FormSnake
        push bp
        mov bp, sp
        push ax  
        
        ; form a snake square        
         
        cmp snake_head_found, TRUE
        jne not_head  
        
        ; if this is the head square, paint it in a different color
        mov ax, SNAKE_SQUARE
        push ax  
        push HEAD_COLOR
        push [SNAKE_X]
        push [SNAKE_Y]
        call CreateSquare 
        
        ; set the boolean to false since we dealt with the head right now, and we don't want to trigger this again in this iteration 
        mov snake_head_found, FALSE
        jmp head_formed
        
    not_head:
        ; create the snake body        
        mov ax, SNAKE_SQUARE
        push ax  
        push SNAKE_COLOR
        push [SNAKE_X]
        push [SNAKE_Y]
        call CreateSquare  
    head_formed:  
      
        ; determine whether the entire snake has been formed or not  
        inc count_snake
        mov ax, snake_length        
        cmp count_snake, ax
        jne finished_phase        
        
        ; if the snake is fully formed update the boolean
        mov formed_snake, TRUE
        
    finished_phase: 
        pop ax  
        pop bp
        ret 6
    endp FormSnake
;==========================================================================
    
    
    proc SpaceSquare
        push ax
        push cx
        push dx 
        
        ; check if the current square is in the same row as the ones before
        mov ax, GET_LENGTH  
        mov cx, SPACE  
        mul cx  
        cmp spacer_x, ax
        jle same_row
        
        ; if the current square is in a new row, then update the y-spacer and reset the x-spacer
        add spacer_y, SPACE 
        mov spacer_x, SPACE 
    same_row:
        ; increase the spacer
        add spacer_x, SPACE
        
        ; update the x and y values accordingly
        mov ax, spacer_x 
        add current_x, ax
        mov ax, spacer_y 
        add current_y, ax 
                          
        pop dx
        pop cx
        pop ax
        ret
    endp SpaceSquare 
    
;==========================================================================

    proc CheckDirection  
        push ax

search_possible_values:       
        mov ah, 1
        int 16h ; get keyboard status
        jz finished_direction_check ; if zero flag is active, then no key was pressed 
        
        ; get the value of the pressed key   
        mov ax, 0      
        int 16h 
        
        cmp ah, 48h ; if up arrow was pressed:
        je up_pressed
        
        cmp ah, 50h ; if down arrow was pressed:   
        je down_pressed    
        
        cmp ah, 4Bh ; if left arrow was pressed: 
        je left_pressed
        
        cmp ah, 4Dh ; if right arrow was pressed: 
        je right_pressed         
        
        jmp finished_direction_check ; niether of the arrows were pressed
        
    up_pressed:
        cmp direction, GOING_DOWN
        je search_possible_values ; this isn't a possible move
        
        mov direction, GOING_UP ; set the direction to the value that indicates up movement   
        mov first_iteration, FALSE
        jmp finished_direction_check 
             
    down_pressed:
        cmp direction, GOING_UP
        je search_possible_values ; this isn't a possible move
    
        mov direction, GOING_DOWN ; set the direction to the value that indicates down movement  
        mov first_iteration, FALSE
        jmp finished_direction_check 
             
    left_pressed:  
        ; if there is no direction yet, since the head is facing right, then left isn't a possible move 
        ; if you change head starting direction, use this in the area of the opposite of the new direction
        cmp first_iteration, TRUE
        je search_possible_values        
        
        cmp direction, GOING_RIGHT
        je search_possible_values ; this isn't a possible move
                         
        mov direction, GOING_LEFT ; set the direction to the value that indicates left movement
        mov first_iteration, FALSE
        jmp finished_direction_check
                  
    right_pressed:
        cmp direction, GOING_LEFT
        je search_possible_values ; this isn't a possible move
    
        mov direction, GOING_RIGHT ; set the direction to the value that indicates right movement
        mov first_iteration, FALSE
                
            
    finished_direction_check:    
        
        pop ax
        ret
    endp CheckDirection  
;==========================================================================
    
    REDIRECT            EQU bp + 4
    HEAD_CELL_POS       EQU bp + 6
    BOARD_ARR_OFFSET    EQU bp + 8   
    COUNT               EQU bp - 2
    proc CheckAndChangeArrValues   
        push bp
        mov bp, sp 
        sub sp, 2
        push ax
        push bx
        push di
        push cx      

        ; reset the boolean
        mov snake_ate_apple, FALSE
        
        ; set the new head position according to the direction
        
        ; check the direction in which the snake is going        
        cmp [REDIRECT], GOING_UP
        je facing_up
        
        cmp [REDIRECT], GOING_DOWN
        je facing_down
        
        cmp [REDIRECT], GOING_LEFT
        je facing_left
        
        cmp [REDIRECT], GOING_RIGHT
        je facing_right
        
        jmp finished_calculating_head_pos          
        
    facing_up:
        ; death check: top border 
        mov ax, GET_LENGTH
        shl ax, 1 
        mov cx, [HEAD_CELL_POS] 
        cmp cx, ax
        jb death 
                
        ;;;;;;;;;; snake is alive, change head position
        
        ; if it is going up, than the new head position is: current_pos - (GET_LENGTH * 2) (times 2 is because it is a word size)
        mov ax, GET_LENGTH                
        shl ax, 1 
        sub [HEAD_CELL_POS], ax  
        jmp finished_calculating_head_pos
        
    facing_down:  
        ; death check: bottom border 
        mov ax, ARR_LENGTH
        sub ax, GET_LENGTH
        shl ax, 1 
        mov cx, [HEAD_CELL_POS] 
        cmp cx, ax
        jae death 
        
        ;;;;;;;;;; snake is alive, change head position
    
        ; if it is going down, than the new head position is: current_pos + (GET_LENGTH * 2) (times 2 is because it is a word size)
        mov ax, GET_LENGTH
        shl ax, 1 
        add [HEAD_CELL_POS], ax
        jmp finished_calculating_head_pos
        
    facing_left:
        ; death check: left border 
        mov ax, [HEAD_CELL_POS] 
        mov cx, GET_LENGTH 
        shl cx, 1
        xor dx, dx
        div cx 
        cmp dx, 0 ; if modulu 16 is zero (no division reminder)
        je death 
        
        ;;;;;;;;;; snake is alive, change head position

        ; if it is going left, than the new head position is: current_pos - 2 (minus 2 is because it is a word size)
        sub [HEAD_CELL_POS], 2
        jmp finished_calculating_head_pos                         
                         
    facing_right:
        ; death check: right border 
        mov ax, [HEAD_CELL_POS]
        add ax, 2 ; if head_pos + 1 is divisble by 16 its in the right border 
        mov cx, GET_LENGTH 
        shl cx, 1
        xor dx, dx
        div cx 
        cmp dx, 0 ; if modulu 16 is zero (no division reminder)
        je death
           
        ;;;;;;;;;; snake is alive, change head position

        ; if it is going left, than the new head position is: current_pos + 2 (plus because it is a word size)
        add [HEAD_CELL_POS], 2     
        jmp finished_calculating_head_pos  
        
    finished_calculating_head_pos:
        ; update the new snake head position  
        mov ax, snake_length 
        ; this will be decremented very soon  
        inc ax
        
        mov bx, [HEAD_CELL_POS]  
        
        ; check if snake ate apple
        cmp axis_arr[bx], 0
        jl snake_eaten_apple
        
        ; check snake death by eating himself
        cmp axis_arr[bx], 1
        jg snake_ate_himself 
        
        jmp snake_didnt_eat

    snake_ate_himself:
        ; call death message prepare for a reset of the game 
        call SnakeDeath
        mov game_needs_to_reset, TRUE
        jmp not_ready_update

    snake_eaten_apple:
        ; prepare for snake growth
        mov snake_ate_apple, TRUE
        inc snake_length
        ; set a new apple position
        call RandomApplePos
        
        ; increase the score
        call IncreaseScore   
        ; check if needs to increase the max score
        push current_score                 
        call CheckMax


    snake_didnt_eat:        
        ; mov the head value (snake_length+1) to the new head position 
        mov axis_arr[bx], ax 
        
        ;;;;;;;;;;
        
        ; decrement every snake value. this will delete the tail and cause a movement.
        ; that is also the reason for the increment of the snake head value beforehand, as it will get decremented now 
        
        ; make a growing by not decrementing the snake values 
        cmp snake_ate_apple, TRUE
        je not_ready_update  
        
        mov di, [BOARD_ARR_OFFSET] ; di will access the array values using "pass by refernce" method 
        mov cx, ARR_LENGTH ; cx will help loop until the last value of the array
        mov ax, 00000000h   
        mov [COUNT], ax ; count is a local variable that will keep track of the indexes  
        
    change_snake_pos_loop:     
        
        ; check if found snake body
        cmp [di], 0
        jg its_snake_body
        
        jmp not_snake


    its_snake_body:
        ; if found snake body, decrement its value
        dec [di]

    not_snake:
        ; keep looking
        add di, 2
        inc [COUNTER]    
        
        loop change_snake_pos_loop
        
        
        ; reset the booleans
        mov formed_snake, FALSE
        mov count_snake, 0 
        jmp not_ready_update  
        
    death:
        call SnakeDeath
        mov game_needs_to_reset, TRUE
                  
    not_ready_update:        
        pop cx
        pop di
        pop bx
        pop ax  
        add sp, 2  
        pop bp
        ret 6
    endp CheckAndChangeArrValues     
    
;===================================================              
   
    proc SnakeDeath
        mov bp, sp   
        push ax
        push bx
        push dx
        push cx
        push di
        
        ; reset the screen
        mov ah, 0
        mov al, 13h
        int 10h
        
        ; print GAME OVER to the screen
        mov ax, OVER_WIDTH 
        push ax
        mov ax, OVER_HEIGHT 
        push ax
        mov ax, OVER_START
        push ax  
        push offset GAME_OVER
        call DrawBigText
        
        ; print the death message
        mov ah, 2
        mov bh, 0
        mov dh, DEATH_MESSAGE_ROW ; row
        mov dl, DEATH_MESSAGE_COL ; col 
        int 10h 
         
        mov ah, 9
        lea dx, death_message 
        int 21h
        ; wait until a key is pressed
        xor ax, ax
        int 16h  
        
        ; reset all the variables
        
        mov snake_cell, 0  
        mov head_cell, 0 
        mov direction, 10                        
        mov snake_length, 4    
        mov count_snake, 0

        mov current_x, 0
        mov current_y, 0       

        mov current_score, 0               

        mov spacer_x, SPACE
        mov spacer_y, SPACE

        mov FORMED_SNAKE, FALSE ; a boolean (0 - false, 1 - true)
        mov snake_ate_apple, FALSE ; a boolean (0 - false, 1 - true) 
        mov first_iteration, TRUE ; a boolean (0 - false, 1 - true)        
        mov snake_head_found, FALSE ; a boolean (0 - false, 1 - true)    
        mov no_point_yet, TRUE ; a boolean (0 - false, 1 - true)        

        mov FIRST_VALUE_OF_LAST_ROW, 0
        mov LAST_VALUE_OF_LAST_ROW, 0
        mov LAST_VALUE_OF_FIRST_ROW, 0      

        
        mov cx, SCORE_STRING_LENGTH
    reset_string:
        mov bx, cx        
        mov SCORE_TO_PRINT[bx], '$'
        loop reset_string 
        
        mov SCORE_STRING_LENGTH, 1          
        
        mov cx, ARR_LENGTH  
        xor di, di
    reset_array:      
        mov axis_arr[di], 0  
        add di, 2
        loop reset_array
        
        ; reset the screen
        xor ah, ah
        mov al, 13h 
        int 10h 
        
        pop di
        pop cx
        pop dx
        pop bx
        pop ax 
        ret
    endp SnakeDeath 
    
    
;==========================================================================
    
    proc RandomApplePos
        push ax
        push dx
        push bx
        push cx

keep_searching:        
        xor ax, ax
        int 1Ah ; al saves the midnight flag. in cx:dx is saved the time ticks since midnight (cx-higher dx-lower). this timer is increased by 18.206 every second.
        mov ax, dx ; lower half of time ticks
        xor dx, dx
        mov cx, ARR_LENGTH 
        div cx ; dx = reminder (0-255)
        
        ; check if the new apple position isn't on the snake, if it is then continue searching
        mov bx, dx
        shl bx, 1
        cmp axis_arr[bx], 0 
        jne keep_searching
        
        ; save the new apple position in the array
        mov axis_arr[bx], -1
        
        pop cx
        pop bx
        pop dx
        pop ax
        ret
    endp RandomApplePos 

;==========================================================================

    proc IncreaseScore
        push ax
        push bx
        push dx
        
        ; increment the integer score value
        inc current_score 
        
        ; if there aren't any points yet we can skip the deleting
        cmp no_point_yet, TRUE
        je skip_backspace
        
        mov ah, 2
        mov bh, 0
        mov dh, PRINT_SCORE_ROW ; row
        mov dl, PRINT_SCORE_COL ; col
        int 10h
        ; delete what is written
        mov ah, 9
        lea dx, BACKSPACES
        int 21h 
        
skip_backspace:                
        push offset SCORE_TO_PRINT 
        push current_score
        call NumToStr ; after this: SCORE_TO_PRINT = SCORE
        
       
        ; set the print position
        mov ah, 2
        mov bh, 0
        mov dh, PRINT_SCORE_ROW ; row
        mov dl, PRINT_SCORE_COL ; col
        int 10h
        
         ; print the score 
        mov ah, 9
        lea dx, SCORE_TO_PRINT
        int 21h 
        
        pop dx
        pop bx
        pop ax
        
        ret 
    endp IncreaseScore  

;==========================================================================    
    
    SCORE_NOW   EQU bp + 4
    
    proc CheckMax
        push bp
        mov bp, sp 
        push ax
        push bx
        push dx 
        
        ; check if there is a need to update the max score variable
        mov ax, [SCORE_NOW] 
        cmp max_score, ax
        jg no_update_max
        
        ; update it 
        mov max_score, ax
        
        ; covert it to a printable string
        push offset MAX_SCORE_TO_PRINT
        push max_score
        call NumToStr
        
    no_update_max: 
    
        mov ah, 2
        mov bh, 0
        mov dh, PRINT_MAX_SCORE_ROW ; row
        mov dl, PRINT_SCORE_COL     ; col
        int 10h
        mov ah, 9   
        
        ; delete what was written
        mov ah, 2
        lea dx, BACKSPACES
        int 21h 
        
        ; set the print position
        mov ah, 2
        mov bh, 0
        mov dh, PRINT_MAX_SCORE_ROW ; row
        mov dl, PRINT_SCORE_COL ; col
        int 10h
        ; print it
        mov ah, 9
        lea dx, MAX_SCORE_TO_PRINT
        int 21h 
        
        pop dx
        pop bx   
        pop ax
         
        pop bp
        ret 2
    endp CheckMax 

;==========================================================================
    
    SCORE_STRING_OFFSET EQU bp + 6
    INTEGER_SCORE       EQU bp + 4
    proc NumToStr  
        push bp
        mov bp, sp
        push ax
        push bx
        push cx
        push dx
        push di
        
        mov ax, [INTEGER_SCORE]
        mov di, [SCORE_STRING_OFFSET]
        mov bx, 10
        xor cx, cx 
        
    get_digits:
        xor dx, dx
        div bx ; dx will save the reminder, since the score is divided by 10, then the reminder will be the rightmost digit     
        push dx ; when I will get it out of the stack it will come in reverse order (as I need)
        
        inc cx ; will be used when we get the values out of the stack
        
        ; the loop will finish when ax will be empty
        cmp ax, 0
        jne get_digits
        
        mov SCORE_STRING_LENGTH, cx
    digit_to_string:
        pop dx ; the numbers will go in reverse, as we need in order to print it correctly
        add dl, 48 ; transform to Ascii
        mov [di], dl ; get the values inside the string variable
        inc di
        loop digit_to_string ; cx keep the string length (incremented length times beforehand)
        
        
        pop di
        pop dx
        pop cx
        pop bx
        pop ax
          
        pop bp
        ret 4
    endp NumToStr 

;===================================
    
    LENGTH          EQU bp + 10
    CHOSEN_COLOR    EQU bp + 8
    X_VALUE         EQU bp + 6
    Y_VALUE         EQU bp + 4
        
    proc CreateSquare    
        push bp
        mov bp, sp
        push ax
        push bx
        push cx
        push dx
        
        ; mov the value to the registers for the int 10h
        mov ah, 0Ch
        mov al, CHOSEN_COLOR 
        mov cx, [X_VALUE]
        mov dx, [Y_VALUE]
        ; keep track of the printing length 
        mov bl, LENGTH
        mov bh, LENGTH  
    form_square:
        mov ah, 0Ch ; write pixel at coordinate 
        int 10h    
        ; print another pixle next to the last one
        inc cx
         
        ; use this in order to check when the current line is finished
        dec bl
        jnz form_square ; check zero flag
        
        ; mov one y axis pos up
        inc dx    
        ; return to start
        mov cx, [X_VALUE]
        mov bl, LENGTH 
        
        ; check if it finished horazonticly 
        dec bh        
        cmp bh, 0
        jne form_square
            
        pop dx
        pop cx
        pop bx
        pop ax    
        
        pop bp
        ret 8 
    endp CreateSquare    

;=========================================================================


end start ; set entry point and stop the assembler.                       